# Autoload
---

[pathinfo](0.1.0-pathinfo.md)一节介绍了`pathinfo`这个概念，我们知道它结合url rewrite可以将一个http请求转发到一个index.php脚本，并把原始的url请求参数通过pathinfo等环境变量带过去。这一节，我要介绍的是PHP的autoload概念。

PHP类加载的机制
---

传统的PHP加载一个类时，首先需要将类所在的代码文件加载进来，那么如何加载呢？php提供两组函数：`include`和`require`。`include`用法如下：

	<?php
    include 'path/to/clsa.php';
    $a = new clsa(); //假设clsa.php提供一个clsa类。

include函数会把`path/to/clsa.php`的代码加载进来，并在当前位置以html模式开启一个新的执行上下文，执行加载进来的类和文件。

注意的是，这里如果你在include进来的代码文件里面定义了一些变量，那么这些变量仅限于执行上下文，但是引入这个文件的父代码文件中的变量可以带入到新的上下文中（即在include进来的php代码文件可以引用父代码文件中的变量）。

同时，include的默认行为是把文件为一个html文档处理，即输出内容。如果你里面包含php代码，你需要用`<?php`标签将语句包含起来。

`require`和`include`的基本相同，唯一的区别在于如果类文件不存在或者有执行出错，那么include只报一个warning，但是require则会产生一个致命错误并中断处理流程。

同时，在使用require时，如果是在流程控制中，无论是否走到该分支，require都会执行。也就是说：

	<?php
	if(true) {
		require 'a.php';
	}
	else require 'b.php';

这里，a.php和b.php都会被加载进来。

>简单说：
>
> * **require** 的英文意思是 '需要，有赖于'。如果使用了这条语句，也就是告诉PHP内核，我这个程序需要这个文件，有赖于这个文件。或者通俗点儿讲就是：我要她！所以，PHP如果发现require参数中的文件不存在的话，就会报fatal error，并且停止执行下面的语句。
> * **include** 的英文意思是 '包括，包含'。如果使用了这条语句，也就是告诉PHP内核，程序执行时，把这个文件包含进来。通俗点儿讲就是：带上她！所以，PHP如果找不到的话，仅仅会提示说，找不到她，无法带上她。而不会停止下面脚本的执行，因为我们并没有告诉PHP内核，下面的程序有赖于这个子文件。
> 参考：<http://blog.sina.com.cn/s/blog_5d2673da0100cp6o.html>

通过`require/include`函数，我们可以在任意位置执行任意类和方法，只要我们把类或者方法所在的代码文件加载到当前执行上下文。

这里`require/include`还有一对姊妹函数`require_once/include_once`，用法类似。但是*_once函数的不同之处是会记住一个已经加载进来的代码文件，如果当前执行上下文已经加载过某代码文件，那么就不会再次加载。这样的好处是避免重复加载造成的命名冲突。

同时，`require/include`还可以有返回值，如果在include进来的代码文件中的非{}片段中有return语句的话，那么这个return语句会作为`require/include`的返回值。

也就是说，我们可以如下做：
	
	// cfg.php
	<?php
	$cfg = [1,2,3];
	return $cfg;
	
在另外一个地方，我们可以如下include这个文件
	
	<?php
		$cfg = require('cfg.php');
		print_r($cfg);

这块更深入的这里不做详细介绍，请自行百度或者谷歌之。

* [require/include用法详解](http://www.cnblogs.com/xia520pi/p/3697099.html)


现在问题来了，什么叫Autoload？
---

在某个php执行上下文中，在new某个类，或者静态调用时如果某个类没有找到，php默认会首先、触发`__autoload`回调，由回调尝试去加载类代码文件。这个回调由用户自己实现，通过用户规定的类名到代码文件的映射规则得到代码文件路径，并使用`require/include`函数去加载代码文件。

比如：

	<?php
	__autoload($clsname) {
		require $clsname.'.php';
	}

	$a = new A();
	
